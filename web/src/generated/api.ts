/* tslint:disable */
/* eslint-disable */
/**
 * RAIDHack API
 * RAIDHackは、開発者がアイデアを共有し、ハッカソンをするためのプラットフォームです。 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AdminStats
 */
export interface AdminStats {
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'users'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'ideas'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'teams'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'works'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'applications'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'votes'?: number;
    /**
     * 
     * @type {AdminStatsRecentActivities}
     * @memberof AdminStats
     */
    'recent_activities'?: AdminStatsRecentActivities;
}
/**
 * 
 * @export
 * @interface AdminStatsRecentActivities
 */
export interface AdminStatsRecentActivities {
    /**
     * 
     * @type {number}
     * @memberof AdminStatsRecentActivities
     */
    'new_users_today'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStatsRecentActivities
     */
    'new_ideas_today'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStatsRecentActivities
     */
    'new_works_today'?: number;
}
/**
 * 
 * @export
 * @interface ApiAdminStatsGet200Response
 */
export interface ApiAdminStatsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiAdminStatsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiAdminStatsGet200Response
     */
    'message': string;
    /**
     * 
     * @type {AdminStats}
     * @memberof ApiAdminStatsGet200Response
     */
    'stats'?: AdminStats;
}
/**
 * 
 * @export
 * @interface ApiApplicationsIdCreateTeamPost201Response
 */
export interface ApiApplicationsIdCreateTeamPost201Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiApplicationsIdCreateTeamPost201Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdCreateTeamPost201Response
     */
    'message': string;
    /**
     * 
     * @type {Team}
     * @memberof ApiApplicationsIdCreateTeamPost201Response
     */
    'team'?: Team;
}
/**
 * 
 * @export
 * @interface ApiAuthGithubCallbackPost200Response
 */
export interface ApiAuthGithubCallbackPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiAuthGithubCallbackPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiAuthGithubCallbackPost200Response
     */
    'message': string;
    /**
     * 
     * @type {User}
     * @memberof ApiAuthGithubCallbackPost200Response
     */
    'user'?: User;
    /**
     * API認証用JWTトークン
     * @type {string}
     * @memberof ApiAuthGithubCallbackPost200Response
     */
    'token'?: string;
    /**
     * GitHubアクセストークン
     * @type {string}
     * @memberof ApiAuthGithubCallbackPost200Response
     */
    'access_token'?: string;
}
/**
 * 
 * @export
 * @interface ApiAuthGithubCallbackPostRequest
 */
export interface ApiAuthGithubCallbackPostRequest {
    /**
     * GitHubから取得した認証コード
     * @type {string}
     * @memberof ApiAuthGithubCallbackPostRequest
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface ApiAuthMeGet200Response
 */
export interface ApiAuthMeGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiAuthMeGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiAuthMeGet200Response
     */
    'message': string;
    /**
     * 
     * @type {User}
     * @memberof ApiAuthMeGet200Response
     */
    'user'?: User;
}
/**
 * 
 * @export
 * @interface ApiIdeasGet200Response
 */
export interface ApiIdeasGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiIdeasGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiIdeasGet200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<Idea>}
     * @memberof ApiIdeasGet200Response
     */
    'ideas'?: Array<Idea>;
    /**
     * 
     * @type {Pagination}
     * @memberof ApiIdeasGet200Response
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface ApiIdeasIdApplicationsApplicationIdPutRequest
 */
export interface ApiIdeasIdApplicationsApplicationIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiIdeasIdApplicationsApplicationIdPutRequest
     */
    'action': ApiIdeasIdApplicationsApplicationIdPutRequestActionEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiIdeasIdApplicationsApplicationIdPutRequest
     */
    'message'?: string;
}

export const ApiIdeasIdApplicationsApplicationIdPutRequestActionEnum = {
    Approve: 'approve',
    Reject: 'reject'
} as const;

export type ApiIdeasIdApplicationsApplicationIdPutRequestActionEnum = typeof ApiIdeasIdApplicationsApplicationIdPutRequestActionEnum[keyof typeof ApiIdeasIdApplicationsApplicationIdPutRequestActionEnum];

/**
 * 
 * @export
 * @interface ApiIdeasIdApplicationsGet200Response
 */
export interface ApiIdeasIdApplicationsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiIdeasIdApplicationsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiIdeasIdApplicationsGet200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<ApplicationDetail>}
     * @memberof ApiIdeasIdApplicationsGet200Response
     */
    'applications'?: Array<ApplicationDetail>;
}
/**
 * 
 * @export
 * @interface ApiIdeasIdApplyPost201Response
 */
export interface ApiIdeasIdApplyPost201Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiIdeasIdApplyPost201Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiIdeasIdApplyPost201Response
     */
    'message': string;
    /**
     * 
     * @type {Application}
     * @memberof ApiIdeasIdApplyPost201Response
     */
    'application'?: Application;
}
/**
 * 
 * @export
 * @interface ApiIdeasIdApplyPostRequest
 */
export interface ApiIdeasIdApplyPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiIdeasIdApplyPostRequest
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiIdeasIdApplyPostRequest
     */
    'motivation'?: string;
}
/**
 * 
 * @export
 * @interface ApiIdeasIdGet200Response
 */
export interface ApiIdeasIdGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiIdeasIdGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiIdeasIdGet200Response
     */
    'message': string;
    /**
     * 
     * @type {IdeaDetail}
     * @memberof ApiIdeasIdGet200Response
     */
    'idea'?: IdeaDetail;
}
/**
 * 
 * @export
 * @interface ApiIdeasIdLikePost200Response
 */
export interface ApiIdeasIdLikePost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiIdeasIdLikePost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiIdeasIdLikePost200Response
     */
    'message': string;
    /**
     * いいね状態
     * @type {boolean}
     * @memberof ApiIdeasIdLikePost200Response
     */
    'liked'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiIdeasPost201Response
 */
export interface ApiIdeasPost201Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiIdeasPost201Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiIdeasPost201Response
     */
    'message': string;
    /**
     * 
     * @type {Idea}
     * @memberof ApiIdeasPost201Response
     */
    'idea'?: Idea;
}
/**
 * 
 * @export
 * @interface ApiIdeasPostRequest
 */
export interface ApiIdeasPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiIdeasPostRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ApiIdeasPostRequest
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiIdeasPostRequest
     */
    'required_skills'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApiNotificationsGet200Response
 */
export interface ApiNotificationsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiNotificationsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiNotificationsGet200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<Notification>}
     * @memberof ApiNotificationsGet200Response
     */
    'notifications'?: Array<Notification>;
    /**
     * 
     * @type {Pagination}
     * @memberof ApiNotificationsGet200Response
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface ApiNotificationsUnreadCountGet200Response
 */
export interface ApiNotificationsUnreadCountGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiNotificationsUnreadCountGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiNotificationsUnreadCountGet200Response
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ApiNotificationsUnreadCountGet200Response
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface ApiTeamsIdDiscordPut200Response
 */
export interface ApiTeamsIdDiscordPut200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiTeamsIdDiscordPut200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiTeamsIdDiscordPut200Response
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTeamsIdDiscordPut200Response
     */
    'discord_url'?: string;
}
/**
 * 
 * @export
 * @interface ApiTeamsIdDiscordPutRequest
 */
export interface ApiTeamsIdDiscordPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiTeamsIdDiscordPutRequest
     */
    'discord_url': string;
}
/**
 * 
 * @export
 * @interface ApiTeamsIdGet200Response
 */
export interface ApiTeamsIdGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiTeamsIdGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiTeamsIdGet200Response
     */
    'message': string;
    /**
     * 
     * @type {TeamDetail}
     * @memberof ApiTeamsIdGet200Response
     */
    'team'?: TeamDetail;
}
/**
 * 
 * @export
 * @interface ApiTeamsMeGet200Response
 */
export interface ApiTeamsMeGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiTeamsMeGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiTeamsMeGet200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<Team>}
     * @memberof ApiTeamsMeGet200Response
     */
    'teams'?: Array<Team>;
}
/**
 * 
 * @export
 * @interface ApiWorksGet200Response
 */
export interface ApiWorksGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiWorksGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiWorksGet200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<Work>}
     * @memberof ApiWorksGet200Response
     */
    'works'?: Array<Work>;
    /**
     * 
     * @type {Pagination}
     * @memberof ApiWorksGet200Response
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface ApiWorksIdGet200Response
 */
export interface ApiWorksIdGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiWorksIdGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiWorksIdGet200Response
     */
    'message': string;
    /**
     * 
     * @type {WorkDetail}
     * @memberof ApiWorksIdGet200Response
     */
    'work'?: WorkDetail;
}
/**
 * 
 * @export
 * @interface ApiWorksIdVotePost200Response
 */
export interface ApiWorksIdVotePost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiWorksIdVotePost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiWorksIdVotePost200Response
     */
    'message': string;
    /**
     * 投票状態
     * @type {boolean}
     * @memberof ApiWorksIdVotePost200Response
     */
    'voted'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiWorksPost201Response
 */
export interface ApiWorksPost201Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiWorksPost201Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiWorksPost201Response
     */
    'message': string;
    /**
     * 
     * @type {Work}
     * @memberof ApiWorksPost201Response
     */
    'work'?: Work;
}
/**
 * 
 * @export
 * @interface ApiWorksPostRequest
 */
export interface ApiWorksPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiWorksPostRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ApiWorksPostRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApiWorksPostRequest
     */
    'demo_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiWorksPostRequest
     */
    'repository_url'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiWorksPostRequest
     */
    'technologies'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ApiWorksPostRequest
     */
    'team_id': number;
}
/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    'idea_id': number;
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    'applicant_id': number;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'motivation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'status': ApplicationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'applied_at': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'reviewed_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'review_message'?: string;
}

export const ApplicationStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type ApplicationStatusEnum = typeof ApplicationStatusEnum[keyof typeof ApplicationStatusEnum];

/**
 * 
 * @export
 * @interface ApplicationDetail
 */
export interface ApplicationDetail {
    /**
     * 
     * @type {number}
     * @memberof ApplicationDetail
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationDetail
     */
    'idea_id': number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationDetail
     */
    'applicant_id': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetail
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetail
     */
    'motivation'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetail
     */
    'status': ApplicationDetailStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetail
     */
    'applied_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetail
     */
    'reviewed_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetail
     */
    'review_message'?: string;
    /**
     * 
     * @type {ApplicationDetailAllOfIdea}
     * @memberof ApplicationDetail
     */
    'idea'?: ApplicationDetailAllOfIdea;
    /**
     * 
     * @type {User}
     * @memberof ApplicationDetail
     */
    'applicant'?: User;
}

export const ApplicationDetailStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type ApplicationDetailStatusEnum = typeof ApplicationDetailStatusEnum[keyof typeof ApplicationDetailStatusEnum];

/**
 * 
 * @export
 * @interface ApplicationDetailAllOfIdea
 */
export interface ApplicationDetailAllOfIdea {
    /**
     * 
     * @type {number}
     * @memberof ApplicationDetailAllOfIdea
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetailAllOfIdea
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetailAllOfIdea
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetailAllOfIdea
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ErrorResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface HealthGet200Response
 */
export interface HealthGet200Response {
    /**
     * 
     * @type {string}
     * @memberof HealthGet200Response
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof HealthGet200Response
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof HealthGet200Response
     */
    'service'?: string;
}
/**
 * 
 * @export
 * @interface Idea
 */
export interface Idea {
    /**
     * 
     * @type {number}
     * @memberof Idea
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Idea
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Idea
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Idea
     */
    'required_skills'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Idea
     */
    'user_id': number;
    /**
     * 
     * @type {string}
     * @memberof Idea
     */
    'status': IdeaStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Idea
     */
    'like_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Idea
     */
    'user_liked'?: boolean;
    /**
     * 
     * @type {IdeaUser}
     * @memberof Idea
     */
    'user'?: IdeaUser;
    /**
     * 
     * @type {string}
     * @memberof Idea
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Idea
     */
    'updated_at': string;
}

export const IdeaStatusEnum = {
    Open: 'open',
    Development: 'development',
    Completed: 'completed'
} as const;

export type IdeaStatusEnum = typeof IdeaStatusEnum[keyof typeof IdeaStatusEnum];

/**
 * 
 * @export
 * @interface IdeaDetail
 */
export interface IdeaDetail {
    /**
     * 
     * @type {number}
     * @memberof IdeaDetail
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof IdeaDetail
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof IdeaDetail
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IdeaDetail
     */
    'required_skills'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof IdeaDetail
     */
    'user_id': number;
    /**
     * 
     * @type {string}
     * @memberof IdeaDetail
     */
    'status': IdeaDetailStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof IdeaDetail
     */
    'like_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IdeaDetail
     */
    'user_liked'?: boolean;
    /**
     * 
     * @type {IdeaUser}
     * @memberof IdeaDetail
     */
    'user'?: IdeaUser;
    /**
     * 
     * @type {string}
     * @memberof IdeaDetail
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof IdeaDetail
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<Application>}
     * @memberof IdeaDetail
     */
    'applications'?: Array<Application>;
}

export const IdeaDetailStatusEnum = {
    Open: 'open',
    Development: 'development',
    Completed: 'completed'
} as const;

export type IdeaDetailStatusEnum = typeof IdeaDetailStatusEnum[keyof typeof IdeaDetailStatusEnum];

/**
 * 
 * @export
 * @interface IdeaUser
 */
export interface IdeaUser {
    /**
     * 
     * @type {number}
     * @memberof IdeaUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof IdeaUser
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdeaUser
     */
    'avatar_url'?: string;
}
/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'user_id': number;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'type': NotificationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'message': string;
    /**
     * 
     * @type {object}
     * @memberof Notification
     */
    'data'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    'is_read': boolean;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'created_at': string;
}

export const NotificationTypeEnum = {
    Application: 'application',
    TeamInvite: 'team_invite',
    ApplicationStatus: 'application_status',
    NewIdea: 'new_idea',
    Vote: 'vote',
    System: 'system'
} as const;

export type NotificationTypeEnum = typeof NotificationTypeEnum[keyof typeof NotificationTypeEnum];

/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'total_pages': number;
}
/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SuccessResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof SuccessResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    'idea_id': number;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'discord_invite_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'status': TeamStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'updated_at': string;
}

export const TeamStatusEnum = {
    Active: 'active',
    Completed: 'completed',
    Disbanded: 'disbanded'
} as const;

export type TeamStatusEnum = typeof TeamStatusEnum[keyof typeof TeamStatusEnum];

/**
 * 
 * @export
 * @interface TeamDetail
 */
export interface TeamDetail {
    /**
     * 
     * @type {number}
     * @memberof TeamDetail
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof TeamDetail
     */
    'idea_id': number;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'discord_invite_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'status': TeamDetailStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<TeamDetailAllOfMembers>}
     * @memberof TeamDetail
     */
    'members'?: Array<TeamDetailAllOfMembers>;
    /**
     * 
     * @type {Idea}
     * @memberof TeamDetail
     */
    'idea'?: Idea;
}

export const TeamDetailStatusEnum = {
    Active: 'active',
    Completed: 'completed',
    Disbanded: 'disbanded'
} as const;

export type TeamDetailStatusEnum = typeof TeamDetailStatusEnum[keyof typeof TeamDetailStatusEnum];

/**
 * 
 * @export
 * @interface TeamDetailAllOfMembers
 */
export interface TeamDetailAllOfMembers {
    /**
     * 
     * @type {number}
     * @memberof TeamDetailAllOfMembers
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailAllOfMembers
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailAllOfMembers
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailAllOfMembers
     */
    'bio'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamDetailAllOfMembers
     */
    'skills'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailAllOfMembers
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailAllOfMembers
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailAllOfMembers
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailAllOfMembers
     */
    'role'?: TeamDetailAllOfMembersRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailAllOfMembers
     */
    'joined_at'?: string;
}

export const TeamDetailAllOfMembersRoleEnum = {
    Leader: 'leader',
    Member: 'member'
} as const;

export type TeamDetailAllOfMembersRoleEnum = typeof TeamDetailAllOfMembersRoleEnum[keyof typeof TeamDetailAllOfMembersRoleEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'bio'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'skills'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface Work
 */
export interface Work {
    /**
     * 
     * @type {number}
     * @memberof Work
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Work
     */
    'team_id': number;
    /**
     * 
     * @type {string}
     * @memberof Work
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Work
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Work
     */
    'demo_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Work
     */
    'repository_url'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Work
     */
    'technologies'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Work
     */
    'status': WorkStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Work
     */
    'submitted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Work
     */
    'published_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Work
     */
    'vote_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Work
     */
    'user_voted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Work
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Work
     */
    'updated_at': string;
}

export const WorkStatusEnum = {
    Draft: 'draft',
    Submitted: 'submitted',
    Published: 'published'
} as const;

export type WorkStatusEnum = typeof WorkStatusEnum[keyof typeof WorkStatusEnum];

/**
 * 
 * @export
 * @interface WorkDetail
 */
export interface WorkDetail {
    /**
     * 
     * @type {number}
     * @memberof WorkDetail
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof WorkDetail
     */
    'team_id': number;
    /**
     * 
     * @type {string}
     * @memberof WorkDetail
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof WorkDetail
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof WorkDetail
     */
    'demo_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkDetail
     */
    'repository_url'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkDetail
     */
    'technologies'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof WorkDetail
     */
    'status': WorkDetailStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkDetail
     */
    'submitted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkDetail
     */
    'published_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkDetail
     */
    'vote_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WorkDetail
     */
    'user_voted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkDetail
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof WorkDetail
     */
    'updated_at': string;
    /**
     * 
     * @type {Team}
     * @memberof WorkDetail
     */
    'team'?: Team;
    /**
     * 
     * @type {Array<User>}
     * @memberof WorkDetail
     */
    'team_members'?: Array<User>;
}

export const WorkDetailStatusEnum = {
    Draft: 'draft',
    Submitted: 'submitted',
    Published: 'published'
} as const;

export type WorkDetailStatusEnum = typeof WorkDetailStatusEnum[keyof typeof WorkDetailStatusEnum];


/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * プラットフォーム全体の統計情報を取得します（管理者のみ）
         * @summary 統計情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminStatsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * プラットフォーム全体の統計情報を取得します（管理者のみ）
         * @summary 統計情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAdminStatsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAdminStatsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAdminStatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.apiAdminStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * プラットフォーム全体の統計情報を取得します（管理者のみ）
         * @summary 統計情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminStatsGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiAdminStatsGet200Response> {
            return localVarFp.apiAdminStatsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * プラットフォーム全体の統計情報を取得します（管理者のみ）
     * @summary 統計情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiAdminStatsGet(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiAdminStatsGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 承認済みの応募からチームを作成します
         * @summary 承認済み応募からチーム作成
         * @param {number} applicationId 応募ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdCreateTeamPost: async (applicationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('apiApplicationsIdCreateTeamPost', 'applicationId', applicationId)
            const localVarPath = `/api/applications/{id}/create-team`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 認証済みユーザーの応募履歴を取得します
         * @summary 自分の応募一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/applications/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 承認済みの応募からチームを作成します
         * @summary 承認済み応募からチーム作成
         * @param {number} applicationId 応募ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsIdCreateTeamPost(applicationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsIdCreateTeamPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsIdCreateTeamPost(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsIdCreateTeamPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 認証済みユーザーの応募履歴を取得します
         * @summary 自分の応募一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiIdeasIdApplicationsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * 承認済みの応募からチームを作成します
         * @summary 承認済み応募からチーム作成
         * @param {number} applicationId 応募ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdCreateTeamPost(applicationId: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiApplicationsIdCreateTeamPost201Response> {
            return localVarFp.apiApplicationsIdCreateTeamPost(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 認証済みユーザーの応募履歴を取得します
         * @summary 自分の応募一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsMeGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiIdeasIdApplicationsGet200Response> {
            return localVarFp.apiApplicationsMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * 承認済みの応募からチームを作成します
     * @summary 承認済み応募からチーム作成
     * @param {number} applicationId 応募ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsIdCreateTeamPost(applicationId: number, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsIdCreateTeamPost(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 認証済みユーザーの応募履歴を取得します
     * @summary 自分の応募一覧取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsMeGet(options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GitHubのOAuth認証コールバックを処理し、JWTトークンを取得します
         * @summary GitHub OAuth認証
         * @param {ApiAuthGithubCallbackPostRequest} apiAuthGithubCallbackPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthGithubCallbackPost: async (apiAuthGithubCallbackPostRequest: ApiAuthGithubCallbackPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiAuthGithubCallbackPostRequest' is not null or undefined
            assertParamExists('apiAuthGithubCallbackPost', 'apiAuthGithubCallbackPostRequest', apiAuthGithubCallbackPostRequest)
            const localVarPath = `/api/auth/github/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiAuthGithubCallbackPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 認証済みユーザーの情報を取得します
         * @summary 現在のユーザー情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * GitHubのOAuth認証コールバックを処理し、JWTトークンを取得します
         * @summary GitHub OAuth認証
         * @param {ApiAuthGithubCallbackPostRequest} apiAuthGithubCallbackPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthGithubCallbackPost(apiAuthGithubCallbackPostRequest: ApiAuthGithubCallbackPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthGithubCallbackPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthGithubCallbackPost(apiAuthGithubCallbackPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.apiAuthGithubCallbackPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 認証済みユーザーの情報を取得します
         * @summary 現在のユーザー情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthMeGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.apiAuthMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * GitHubのOAuth認証コールバックを処理し、JWTトークンを取得します
         * @summary GitHub OAuth認証
         * @param {ApiAuthGithubCallbackPostRequest} apiAuthGithubCallbackPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthGithubCallbackPost(apiAuthGithubCallbackPostRequest: ApiAuthGithubCallbackPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiAuthGithubCallbackPost200Response> {
            return localVarFp.apiAuthGithubCallbackPost(apiAuthGithubCallbackPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 認証済みユーザーの情報を取得します
         * @summary 現在のユーザー情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthMeGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiAuthMeGet200Response> {
            return localVarFp.apiAuthMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * GitHubのOAuth認証コールバックを処理し、JWTトークンを取得します
     * @summary GitHub OAuth認証
     * @param {ApiAuthGithubCallbackPostRequest} apiAuthGithubCallbackPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public apiAuthGithubCallbackPost(apiAuthGithubCallbackPostRequest: ApiAuthGithubCallbackPostRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).apiAuthGithubCallbackPost(apiAuthGithubCallbackPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 認証済みユーザーの情報を取得します
     * @summary 現在のユーザー情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public apiAuthMeGet(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).apiAuthMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdeasApi - axios parameter creator
 * @export
 */
export const IdeasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 公開されているアイデアの一覧を取得します
         * @summary アイデア一覧取得
         * @param {number} [page] ページ番号
         * @param {number} [limit] 1ページあたりの件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasGet: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ideas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * アイデア作成者が応募を承認または拒否します
         * @summary 応募の承認・拒否
         * @param {number} id アイデアID
         * @param {number} applicationId 応募ID
         * @param {ApiIdeasIdApplicationsApplicationIdPutRequest} apiIdeasIdApplicationsApplicationIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasIdApplicationsApplicationIdPut: async (id: number, applicationId: number, apiIdeasIdApplicationsApplicationIdPutRequest: ApiIdeasIdApplicationsApplicationIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIdeasIdApplicationsApplicationIdPut', 'id', id)
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('apiIdeasIdApplicationsApplicationIdPut', 'applicationId', applicationId)
            // verify required parameter 'apiIdeasIdApplicationsApplicationIdPutRequest' is not null or undefined
            assertParamExists('apiIdeasIdApplicationsApplicationIdPut', 'apiIdeasIdApplicationsApplicationIdPutRequest', apiIdeasIdApplicationsApplicationIdPutRequest)
            const localVarPath = `/api/ideas/{id}/applications/{applicationId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiIdeasIdApplicationsApplicationIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * アイデア作成者のみ、そのアイデアへの応募一覧を取得できます
         * @summary アイデアの応募一覧取得
         * @param {number} id アイデアID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasIdApplicationsGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIdeasIdApplicationsGet', 'id', id)
            const localVarPath = `/api/ideas/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたアイデアに参加応募を行います
         * @summary アイデアに応募
         * @param {number} id アイデアID
         * @param {ApiIdeasIdApplyPostRequest} apiIdeasIdApplyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasIdApplyPost: async (id: number, apiIdeasIdApplyPostRequest: ApiIdeasIdApplyPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIdeasIdApplyPost', 'id', id)
            // verify required parameter 'apiIdeasIdApplyPostRequest' is not null or undefined
            assertParamExists('apiIdeasIdApplyPost', 'apiIdeasIdApplyPostRequest', apiIdeasIdApplyPostRequest)
            const localVarPath = `/api/ideas/{id}/apply`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiIdeasIdApplyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたIDのアイデア詳細を取得します
         * @summary アイデア詳細取得
         * @param {number} id アイデアID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIdeasIdGet', 'id', id)
            const localVarPath = `/api/ideas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたアイデアにいいねまたはいいね解除を行います
         * @summary アイデアにいいね/いいね解除
         * @param {number} id アイデアID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasIdLikePost: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIdeasIdLikePost', 'id', id)
            const localVarPath = `/api/ideas/{id}/like`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しいアイデアを投稿します
         * @summary アイデア投稿
         * @param {ApiIdeasPostRequest} apiIdeasPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasPost: async (apiIdeasPostRequest: ApiIdeasPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiIdeasPostRequest' is not null or undefined
            assertParamExists('apiIdeasPost', 'apiIdeasPostRequest', apiIdeasPostRequest)
            const localVarPath = `/api/ideas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiIdeasPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdeasApi - functional programming interface
 * @export
 */
export const IdeasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdeasApiAxiosParamCreator(configuration)
    return {
        /**
         * 公開されているアイデアの一覧を取得します
         * @summary アイデア一覧取得
         * @param {number} [page] ページ番号
         * @param {number} [limit] 1ページあたりの件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIdeasGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiIdeasGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIdeasGet(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.apiIdeasGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * アイデア作成者が応募を承認または拒否します
         * @summary 応募の承認・拒否
         * @param {number} id アイデアID
         * @param {number} applicationId 応募ID
         * @param {ApiIdeasIdApplicationsApplicationIdPutRequest} apiIdeasIdApplicationsApplicationIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIdeasIdApplicationsApplicationIdPut(id: number, applicationId: number, apiIdeasIdApplicationsApplicationIdPutRequest: ApiIdeasIdApplicationsApplicationIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiIdeasIdApplyPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIdeasIdApplicationsApplicationIdPut(id, applicationId, apiIdeasIdApplicationsApplicationIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.apiIdeasIdApplicationsApplicationIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * アイデア作成者のみ、そのアイデアへの応募一覧を取得できます
         * @summary アイデアの応募一覧取得
         * @param {number} id アイデアID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIdeasIdApplicationsGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiIdeasIdApplicationsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIdeasIdApplicationsGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.apiIdeasIdApplicationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたアイデアに参加応募を行います
         * @summary アイデアに応募
         * @param {number} id アイデアID
         * @param {ApiIdeasIdApplyPostRequest} apiIdeasIdApplyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIdeasIdApplyPost(id: number, apiIdeasIdApplyPostRequest: ApiIdeasIdApplyPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiIdeasIdApplyPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIdeasIdApplyPost(id, apiIdeasIdApplyPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.apiIdeasIdApplyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたIDのアイデア詳細を取得します
         * @summary アイデア詳細取得
         * @param {number} id アイデアID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIdeasIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiIdeasIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIdeasIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.apiIdeasIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたアイデアにいいねまたはいいね解除を行います
         * @summary アイデアにいいね/いいね解除
         * @param {number} id アイデアID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIdeasIdLikePost(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiIdeasIdLikePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIdeasIdLikePost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.apiIdeasIdLikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しいアイデアを投稿します
         * @summary アイデア投稿
         * @param {ApiIdeasPostRequest} apiIdeasPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIdeasPost(apiIdeasPostRequest: ApiIdeasPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiIdeasPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIdeasPost(apiIdeasPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeasApi.apiIdeasPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdeasApi - factory interface
 * @export
 */
export const IdeasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdeasApiFp(configuration)
    return {
        /**
         * 公開されているアイデアの一覧を取得します
         * @summary アイデア一覧取得
         * @param {number} [page] ページ番号
         * @param {number} [limit] 1ページあたりの件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiIdeasGet200Response> {
            return localVarFp.apiIdeasGet(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * アイデア作成者が応募を承認または拒否します
         * @summary 応募の承認・拒否
         * @param {number} id アイデアID
         * @param {number} applicationId 応募ID
         * @param {ApiIdeasIdApplicationsApplicationIdPutRequest} apiIdeasIdApplicationsApplicationIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasIdApplicationsApplicationIdPut(id: number, applicationId: number, apiIdeasIdApplicationsApplicationIdPutRequest: ApiIdeasIdApplicationsApplicationIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiIdeasIdApplyPost201Response> {
            return localVarFp.apiIdeasIdApplicationsApplicationIdPut(id, applicationId, apiIdeasIdApplicationsApplicationIdPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * アイデア作成者のみ、そのアイデアへの応募一覧を取得できます
         * @summary アイデアの応募一覧取得
         * @param {number} id アイデアID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasIdApplicationsGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiIdeasIdApplicationsGet200Response> {
            return localVarFp.apiIdeasIdApplicationsGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたアイデアに参加応募を行います
         * @summary アイデアに応募
         * @param {number} id アイデアID
         * @param {ApiIdeasIdApplyPostRequest} apiIdeasIdApplyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasIdApplyPost(id: number, apiIdeasIdApplyPostRequest: ApiIdeasIdApplyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiIdeasIdApplyPost201Response> {
            return localVarFp.apiIdeasIdApplyPost(id, apiIdeasIdApplyPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたIDのアイデア詳細を取得します
         * @summary アイデア詳細取得
         * @param {number} id アイデアID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiIdeasIdGet200Response> {
            return localVarFp.apiIdeasIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたアイデアにいいねまたはいいね解除を行います
         * @summary アイデアにいいね/いいね解除
         * @param {number} id アイデアID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasIdLikePost(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiIdeasIdLikePost200Response> {
            return localVarFp.apiIdeasIdLikePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しいアイデアを投稿します
         * @summary アイデア投稿
         * @param {ApiIdeasPostRequest} apiIdeasPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdeasPost(apiIdeasPostRequest: ApiIdeasPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiIdeasPost201Response> {
            return localVarFp.apiIdeasPost(apiIdeasPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdeasApi - object-oriented interface
 * @export
 * @class IdeasApi
 * @extends {BaseAPI}
 */
export class IdeasApi extends BaseAPI {
    /**
     * 公開されているアイデアの一覧を取得します
     * @summary アイデア一覧取得
     * @param {number} [page] ページ番号
     * @param {number} [limit] 1ページあたりの件数
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public apiIdeasGet(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).apiIdeasGet(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * アイデア作成者が応募を承認または拒否します
     * @summary 応募の承認・拒否
     * @param {number} id アイデアID
     * @param {number} applicationId 応募ID
     * @param {ApiIdeasIdApplicationsApplicationIdPutRequest} apiIdeasIdApplicationsApplicationIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public apiIdeasIdApplicationsApplicationIdPut(id: number, applicationId: number, apiIdeasIdApplicationsApplicationIdPutRequest: ApiIdeasIdApplicationsApplicationIdPutRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).apiIdeasIdApplicationsApplicationIdPut(id, applicationId, apiIdeasIdApplicationsApplicationIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * アイデア作成者のみ、そのアイデアへの応募一覧を取得できます
     * @summary アイデアの応募一覧取得
     * @param {number} id アイデアID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public apiIdeasIdApplicationsGet(id: number, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).apiIdeasIdApplicationsGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたアイデアに参加応募を行います
     * @summary アイデアに応募
     * @param {number} id アイデアID
     * @param {ApiIdeasIdApplyPostRequest} apiIdeasIdApplyPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public apiIdeasIdApplyPost(id: number, apiIdeasIdApplyPostRequest: ApiIdeasIdApplyPostRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).apiIdeasIdApplyPost(id, apiIdeasIdApplyPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたIDのアイデア詳細を取得します
     * @summary アイデア詳細取得
     * @param {number} id アイデアID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public apiIdeasIdGet(id: number, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).apiIdeasIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたアイデアにいいねまたはいいね解除を行います
     * @summary アイデアにいいね/いいね解除
     * @param {number} id アイデアID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public apiIdeasIdLikePost(id: number, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).apiIdeasIdLikePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しいアイデアを投稿します
     * @summary アイデア投稿
     * @param {ApiIdeasPostRequest} apiIdeasPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeasApi
     */
    public apiIdeasPost(apiIdeasPostRequest: ApiIdeasPostRequest, options?: RawAxiosRequestConfig) {
        return IdeasApiFp(this.configuration).apiIdeasPost(apiIdeasPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 認証済みユーザーの通知一覧を取得します
         * @summary 通知一覧取得
         * @param {number} [page] ページ番号
         * @param {number} [limit] 1ページあたりの件数
         * @param {boolean} [unreadOnly] 未読のみ取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsGet: async (page?: number, limit?: number, unreadOnly?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (unreadOnly !== undefined) {
                localVarQueryParameter['unread_only'] = unreadOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された通知を削除します
         * @summary 通知削除
         * @param {number} id 通知ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiNotificationsIdDelete', 'id', id)
            const localVarPath = `/api/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された通知を既読にします
         * @summary 通知既読マーク
         * @param {number} id 通知ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsIdReadPut: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiNotificationsIdReadPut', 'id', id)
            const localVarPath = `/api/notifications/{id}/read`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 認証済みユーザーの全ての通知を既読にします
         * @summary 全通知既読マーク
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsReadAllPut: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications/read-all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 認証済みユーザーの未読通知数を取得します
         * @summary 未読通知数取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsUnreadCountGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications/unread-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 認証済みユーザーの通知一覧を取得します
         * @summary 通知一覧取得
         * @param {number} [page] ページ番号
         * @param {number} [limit] 1ページあたりの件数
         * @param {boolean} [unreadOnly] 未読のみ取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsGet(page?: number, limit?: number, unreadOnly?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiNotificationsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNotificationsGet(page, limit, unreadOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.apiNotificationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された通知を削除します
         * @summary 通知削除
         * @param {number} id 通知ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNotificationsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.apiNotificationsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された通知を既読にします
         * @summary 通知既読マーク
         * @param {number} id 通知ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsIdReadPut(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNotificationsIdReadPut(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.apiNotificationsIdReadPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 認証済みユーザーの全ての通知を既読にします
         * @summary 全通知既読マーク
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsReadAllPut(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNotificationsReadAllPut(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.apiNotificationsReadAllPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 認証済みユーザーの未読通知数を取得します
         * @summary 未読通知数取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsUnreadCountGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiNotificationsUnreadCountGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNotificationsUnreadCountGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.apiNotificationsUnreadCountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 認証済みユーザーの通知一覧を取得します
         * @summary 通知一覧取得
         * @param {number} [page] ページ番号
         * @param {number} [limit] 1ページあたりの件数
         * @param {boolean} [unreadOnly] 未読のみ取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsGet(page?: number, limit?: number, unreadOnly?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ApiNotificationsGet200Response> {
            return localVarFp.apiNotificationsGet(page, limit, unreadOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された通知を削除します
         * @summary 通知削除
         * @param {number} id 通知ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.apiNotificationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された通知を既読にします
         * @summary 通知既読マーク
         * @param {number} id 通知ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsIdReadPut(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.apiNotificationsIdReadPut(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 認証済みユーザーの全ての通知を既読にします
         * @summary 全通知既読マーク
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsReadAllPut(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.apiNotificationsReadAllPut(options).then((request) => request(axios, basePath));
        },
        /**
         * 認証済みユーザーの未読通知数を取得します
         * @summary 未読通知数取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsUnreadCountGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiNotificationsUnreadCountGet200Response> {
            return localVarFp.apiNotificationsUnreadCountGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 認証済みユーザーの通知一覧を取得します
     * @summary 通知一覧取得
     * @param {number} [page] ページ番号
     * @param {number} [limit] 1ページあたりの件数
     * @param {boolean} [unreadOnly] 未読のみ取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public apiNotificationsGet(page?: number, limit?: number, unreadOnly?: boolean, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).apiNotificationsGet(page, limit, unreadOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された通知を削除します
     * @summary 通知削除
     * @param {number} id 通知ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public apiNotificationsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).apiNotificationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された通知を既読にします
     * @summary 通知既読マーク
     * @param {number} id 通知ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public apiNotificationsIdReadPut(id: number, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).apiNotificationsIdReadPut(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 認証済みユーザーの全ての通知を既読にします
     * @summary 全通知既読マーク
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public apiNotificationsReadAllPut(options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).apiNotificationsReadAllPut(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 認証済みユーザーの未読通知数を取得します
     * @summary 未読通知数取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public apiNotificationsUnreadCountGet(options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).apiNotificationsUnreadCountGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * APIサーバーの動作状況を確認します
         * @summary ヘルスチェック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * APIサーバーの動作状況を確認します
         * @summary ヘルスチェック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.healthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * APIサーバーの動作状況を確認します
         * @summary ヘルスチェック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: RawAxiosRequestConfig): AxiosPromise<HealthGet200Response> {
            return localVarFp.healthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * APIサーバーの動作状況を確認します
     * @summary ヘルスチェック
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public healthGet(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).healthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamsApi - axios parameter creator
 * @export
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * チームリーダーがチームを解散します
         * @summary チーム解散
         * @param {number} id チームID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTeamsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiTeamsIdDelete', 'id', id)
            const localVarPath = `/api/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * チームリーダーがDiscord招待URLを設定します
         * @summary Discord招待URL設定
         * @param {number} id チームID
         * @param {ApiTeamsIdDiscordPutRequest} apiTeamsIdDiscordPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTeamsIdDiscordPut: async (id: number, apiTeamsIdDiscordPutRequest: ApiTeamsIdDiscordPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiTeamsIdDiscordPut', 'id', id)
            // verify required parameter 'apiTeamsIdDiscordPutRequest' is not null or undefined
            assertParamExists('apiTeamsIdDiscordPut', 'apiTeamsIdDiscordPutRequest', apiTeamsIdDiscordPutRequest)
            const localVarPath = `/api/teams/{id}/discord`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTeamsIdDiscordPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたチームの詳細情報を取得します（チームメンバーのみ）
         * @summary チーム詳細取得
         * @param {number} id チームID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTeamsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiTeamsIdGet', 'id', id)
            const localVarPath = `/api/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 認証済みユーザーが参加しているチーム一覧を取得します
         * @summary 参加チーム一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTeamsMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/teams/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsApiAxiosParamCreator(configuration)
    return {
        /**
         * チームリーダーがチームを解散します
         * @summary チーム解散
         * @param {number} id チームID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTeamsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTeamsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.apiTeamsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * チームリーダーがDiscord招待URLを設定します
         * @summary Discord招待URL設定
         * @param {number} id チームID
         * @param {ApiTeamsIdDiscordPutRequest} apiTeamsIdDiscordPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTeamsIdDiscordPut(id: number, apiTeamsIdDiscordPutRequest: ApiTeamsIdDiscordPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTeamsIdDiscordPut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTeamsIdDiscordPut(id, apiTeamsIdDiscordPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.apiTeamsIdDiscordPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定されたチームの詳細情報を取得します（チームメンバーのみ）
         * @summary チーム詳細取得
         * @param {number} id チームID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTeamsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTeamsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTeamsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.apiTeamsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 認証済みユーザーが参加しているチーム一覧を取得します
         * @summary 参加チーム一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTeamsMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTeamsMeGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTeamsMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.apiTeamsMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsApiFp(configuration)
    return {
        /**
         * チームリーダーがチームを解散します
         * @summary チーム解散
         * @param {number} id チームID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTeamsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.apiTeamsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * チームリーダーがDiscord招待URLを設定します
         * @summary Discord招待URL設定
         * @param {number} id チームID
         * @param {ApiTeamsIdDiscordPutRequest} apiTeamsIdDiscordPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTeamsIdDiscordPut(id: number, apiTeamsIdDiscordPutRequest: ApiTeamsIdDiscordPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiTeamsIdDiscordPut200Response> {
            return localVarFp.apiTeamsIdDiscordPut(id, apiTeamsIdDiscordPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたチームの詳細情報を取得します（チームメンバーのみ）
         * @summary チーム詳細取得
         * @param {number} id チームID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTeamsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiTeamsIdGet200Response> {
            return localVarFp.apiTeamsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 認証済みユーザーが参加しているチーム一覧を取得します
         * @summary 参加チーム一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTeamsMeGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiTeamsMeGet200Response> {
            return localVarFp.apiTeamsMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * チームリーダーがチームを解散します
     * @summary チーム解散
     * @param {number} id チームID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public apiTeamsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).apiTeamsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * チームリーダーがDiscord招待URLを設定します
     * @summary Discord招待URL設定
     * @param {number} id チームID
     * @param {ApiTeamsIdDiscordPutRequest} apiTeamsIdDiscordPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public apiTeamsIdDiscordPut(id: number, apiTeamsIdDiscordPutRequest: ApiTeamsIdDiscordPutRequest, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).apiTeamsIdDiscordPut(id, apiTeamsIdDiscordPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたチームの詳細情報を取得します（チームメンバーのみ）
     * @summary チーム詳細取得
     * @param {number} id チームID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public apiTeamsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).apiTeamsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 認証済みユーザーが参加しているチーム一覧を取得します
     * @summary 参加チーム一覧取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public apiTeamsMeGet(options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).apiTeamsMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorksApi - axios parameter creator
 * @export
 */
export const WorksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 投稿された作品の一覧を取得します
         * @summary 作品一覧取得
         * @param {number} [page] ページ番号
         * @param {number} [limit] 1ページあたりの件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWorksGet: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/works`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された作品の詳細情報を取得します
         * @summary 作品詳細取得
         * @param {number} id 作品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWorksIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWorksIdGet', 'id', id)
            const localVarPath = `/api/works/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定された作品に投票または投票解除を行います
         * @summary 作品に投票/投票解除
         * @param {number} id 作品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWorksIdVotePost: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWorksIdVotePost', 'id', id)
            const localVarPath = `/api/works/{id}/vote`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しい作品を投稿します
         * @summary 作品投稿
         * @param {ApiWorksPostRequest} apiWorksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWorksPost: async (apiWorksPostRequest: ApiWorksPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiWorksPostRequest' is not null or undefined
            assertParamExists('apiWorksPost', 'apiWorksPostRequest', apiWorksPostRequest)
            const localVarPath = `/api/works`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiWorksPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorksApi - functional programming interface
 * @export
 */
export const WorksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorksApiAxiosParamCreator(configuration)
    return {
        /**
         * 投稿された作品の一覧を取得します
         * @summary 作品一覧取得
         * @param {number} [page] ページ番号
         * @param {number} [limit] 1ページあたりの件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWorksGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiWorksGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWorksGet(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorksApi.apiWorksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された作品の詳細情報を取得します
         * @summary 作品詳細取得
         * @param {number} id 作品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWorksIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiWorksIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWorksIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorksApi.apiWorksIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定された作品に投票または投票解除を行います
         * @summary 作品に投票/投票解除
         * @param {number} id 作品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWorksIdVotePost(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiWorksIdVotePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWorksIdVotePost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorksApi.apiWorksIdVotePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しい作品を投稿します
         * @summary 作品投稿
         * @param {ApiWorksPostRequest} apiWorksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWorksPost(apiWorksPostRequest: ApiWorksPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiWorksPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWorksPost(apiWorksPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorksApi.apiWorksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorksApi - factory interface
 * @export
 */
export const WorksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorksApiFp(configuration)
    return {
        /**
         * 投稿された作品の一覧を取得します
         * @summary 作品一覧取得
         * @param {number} [page] ページ番号
         * @param {number} [limit] 1ページあたりの件数
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWorksGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiWorksGet200Response> {
            return localVarFp.apiWorksGet(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された作品の詳細情報を取得します
         * @summary 作品詳細取得
         * @param {number} id 作品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWorksIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiWorksIdGet200Response> {
            return localVarFp.apiWorksIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定された作品に投票または投票解除を行います
         * @summary 作品に投票/投票解除
         * @param {number} id 作品ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWorksIdVotePost(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiWorksIdVotePost200Response> {
            return localVarFp.apiWorksIdVotePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しい作品を投稿します
         * @summary 作品投稿
         * @param {ApiWorksPostRequest} apiWorksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWorksPost(apiWorksPostRequest: ApiWorksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiWorksPost201Response> {
            return localVarFp.apiWorksPost(apiWorksPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorksApi - object-oriented interface
 * @export
 * @class WorksApi
 * @extends {BaseAPI}
 */
export class WorksApi extends BaseAPI {
    /**
     * 投稿された作品の一覧を取得します
     * @summary 作品一覧取得
     * @param {number} [page] ページ番号
     * @param {number} [limit] 1ページあたりの件数
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorksApi
     */
    public apiWorksGet(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return WorksApiFp(this.configuration).apiWorksGet(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された作品の詳細情報を取得します
     * @summary 作品詳細取得
     * @param {number} id 作品ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorksApi
     */
    public apiWorksIdGet(id: number, options?: RawAxiosRequestConfig) {
        return WorksApiFp(this.configuration).apiWorksIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定された作品に投票または投票解除を行います
     * @summary 作品に投票/投票解除
     * @param {number} id 作品ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorksApi
     */
    public apiWorksIdVotePost(id: number, options?: RawAxiosRequestConfig) {
        return WorksApiFp(this.configuration).apiWorksIdVotePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しい作品を投稿します
     * @summary 作品投稿
     * @param {ApiWorksPostRequest} apiWorksPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorksApi
     */
    public apiWorksPost(apiWorksPostRequest: ApiWorksPostRequest, options?: RawAxiosRequestConfig) {
        return WorksApiFp(this.configuration).apiWorksPost(apiWorksPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



